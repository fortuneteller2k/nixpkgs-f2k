From e7e2ce56e4668efa90adf079086992438ae0e9f8 Mon Sep 17 00:00:00 2001
From: Xinhao Yuan <xinhaoyuan@gmail.com>
Date: Tue, 19 Jul 2022 19:07:57 -0400
Subject: [PATCH] Custom composite suppport.

---
 awesome.c           |  16 ++++
 awesomeConfig.cmake |   2 +
 event.c             |  19 ++++
 globalconf.h        |   5 +
 objects/client.c    | 220 +++++++++++++++++++++++++++++++++++++++++---
 objects/client.h    |   6 ++
 6 files changed, 257 insertions(+), 11 deletions(-)

diff --git a/awesome.c b/awesome.c
index 2b17c725fc..f882d31277 100644
--- a/awesome.c
+++ b/awesome.c
@@ -55,6 +55,8 @@
 #include <xcb/xtest.h>
 #include <xcb/shape.h>
 #include <xcb/xfixes.h>
+#include <xcb/composite.h>
+#include <xcb/damage.h>
 
 #include <glib-unix.h>
 
@@ -725,6 +727,8 @@ main(int argc, char **argv)
     xcb_prefetch_extension_data(globalconf.connection, &xcb_xinerama_id);
     xcb_prefetch_extension_data(globalconf.connection, &xcb_shape_id);
     xcb_prefetch_extension_data(globalconf.connection, &xcb_xfixes_id);
+    xcb_prefetch_extension_data(globalconf.connection, &xcb_composite_id);
+    xcb_prefetch_extension_data(globalconf.connection, &xcb_damage_id);
 
     if (xcb_cursor_context_new(globalconf.connection, globalconf.screen, &globalconf.cursor_ctx) < 0)
         fatal("Failed to initialize xcb-cursor");
@@ -793,6 +797,18 @@ main(int argc, char **argv)
         xcb_discard_reply(globalconf.connection,
                 xcb_xfixes_query_version(globalconf.connection, 1, 0).sequence);
 
+    query = xcb_get_extension_data(globalconf.connection, &xcb_composite_id);
+    globalconf.have_composite = query && query->present;
+    if (globalconf.have_composite)
+        xcb_discard_reply(globalconf.connection,
+                xcb_composite_query_version(globalconf.connection, 0, 4).sequence);
+
+    query = xcb_get_extension_data(globalconf.connection, &xcb_damage_id);
+    globalconf.have_damage = query && query->present;
+    if (globalconf.have_damage)
+        xcb_discard_reply(globalconf.connection,
+                xcb_damage_query_version(globalconf.connection, 1, 1).sequence);
+
     event_init();
 
     /* Allocate the key symbols */
diff --git a/awesomeConfig.cmake b/awesomeConfig.cmake
index 592c2b2526..83928a3d52 100644
--- a/awesomeConfig.cmake
+++ b/awesomeConfig.cmake
@@ -148,6 +148,8 @@ set(AWESOME_DEPENDENCIES
     xcb-icccm
     xcb-icccm>=0.3.8
     xcb-xfixes
+    xcb-composite
+    xcb-damage
     # NOTE: it's not clear what version is required, but 1.10 works at least.
     # See https://github.com/awesomeWM/awesome/pull/149#issuecomment-94208356.
     xcb-xkb
diff --git a/event.c b/event.c
index ece985e70c..a383c7cde4 100644
--- a/event.c
+++ b/event.c
@@ -1056,6 +1056,20 @@ event_handle_selectionclear(xcb_selection_clear_event_t *ev)
         selection_handle_selectionclear(ev);
 }
 
+static void
+event_handle_damage_notify(xcb_damage_notify_event_t *ev) {
+    client_t *client;
+    if ((client = client_getbywin(ev->drawable)) && client->composite_cb) {
+        client_refresh_partial(
+            client,
+            ev->area.x + client->titlebar[CLIENT_TITLEBAR_LEFT].size - client->titlebar[CLIENT_TITLEBAR_LEFT].overlap,
+            ev->area.y + client->titlebar[CLIENT_TITLEBAR_TOP].size - client->titlebar[CLIENT_TITLEBAR_TOP].overlap,
+            ev->area.width, ev->area.height);
+        if (ev->damage == client->damage)
+            xcb_damage_subtract(globalconf.connection, ev->damage, None, None);
+    }
+}
+
 /** \brief awesome xerror function.
  * There's no way to check accesses to destroyed windows, thus those cases are
  * ignored (especially on UnmapNotify's).
@@ -1176,6 +1190,7 @@ void event_handle(xcb_generic_event_t *event)
     EXTENSION_EVENT(shape, XCB_SHAPE_NOTIFY, event_handle_shape_notify);
     EXTENSION_EVENT(xkb, 0, event_handle_xkb_notify);
     EXTENSION_EVENT(xfixes, XCB_XFIXES_SELECTION_NOTIFY, event_handle_xfixes_selection_notify);
+    EXTENSION_EVENT(damage, XCB_DAMAGE_NOTIFY, event_handle_damage_notify);
 #undef EXTENSION_EVENT
 }
 
@@ -1198,6 +1213,10 @@ void event_init(void)
     reply = xcb_get_extension_data(globalconf.connection, &xcb_xfixes_id);
     if (reply && reply->present)
         globalconf.event_base_xfixes = reply->first_event;
+
+    reply = xcb_get_extension_data(globalconf.connection, &xcb_damage_id);
+    if (reply && reply->present)
+        globalconf.event_base_damage = reply->first_event;
 }
 
 // vim: filetype=c:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:textwidth=80
diff --git a/globalconf.h b/globalconf.h
index 970849bf57..cd4854f750 100644
--- a/globalconf.h
+++ b/globalconf.h
@@ -126,6 +126,10 @@ typedef struct
     bool have_xkb;
     /** Check for XFixes extension */
     bool have_xfixes;
+    /** Check for Composite extension */
+    bool have_composite;
+    /** Check for Damage extenion */
+    bool have_damage;
     /** Custom searchpaths are present, the runtime is tinted */
     bool have_searchpaths;
     /** When --no-argb is used in the modeline or command line */
@@ -134,6 +138,7 @@ typedef struct
     uint8_t event_base_xkb;
     uint8_t event_base_randr;
     uint8_t event_base_xfixes;
+    uint8_t event_base_damage;
     /** Clients list */
     client_array_t clients;
     /** Embedded windows */
diff --git a/objects/client.c b/objects/client.c
index 4f6a858e76..2bda87ab98 100644
--- a/objects/client.c
+++ b/objects/client.c
@@ -106,6 +106,7 @@
 
 #include <xcb/xcb_atom.h>
 #include <xcb/shape.h>
+#include <xcb/composite.h>
 #include <cairo-xcb.h>
 
 lua_class_t client_class;
@@ -2138,6 +2139,8 @@ client_manage(xcb_window_t w, xcb_get_geometry_reply_t *wgeom, xcb_get_window_at
                           0,
                           globalconf.default_cmap
                       });
+    c->composite_cb = NULL;
+    c->damage = XCB_NONE;
 
     /* The client may already be mapped, thus we must be sure that we don't send
      * ourselves an UnmapNotify due to the xcb_reparent_window().
@@ -2986,6 +2989,16 @@ client_unmanage(client_t *c, client_unmanage_t reason)
         lua_pop(L, 1);
     }
 
+    if (c->composite_cb) {
+        luaA_object_unref(L, c->composite_cb);
+        c->composite_cb = NULL;
+        xcb_composite_unredirect_subwindows(globalconf.connection, c->frame_window, XCB_COMPOSITE_REDIRECT_MANUAL);
+        if (reason != CLIENT_UNMANAGE_DESTROYED &&
+            reason != CLIENT_UNMANAGE_UNMAP)
+            xcb_damage_destroy(globalconf.connection, c->damage);
+        c->damage = XCB_NONE;
+    }
+
     /* Clear our event mask so that we don't receive any events from now on,
      * especially not for the following requests. */
     if(reason != CLIENT_UNMANAGE_DESTROYED)
@@ -3505,6 +3518,26 @@ client_get_drawable(client_t *c, int x, int y)
     return client_get_drawable_offset(c, &x, &y);
 }
 
+static int
+area_intersect(area_t *area, const area_t *intersect_with) {
+    int sx = area->x;
+    int sy = area->y;
+    int ex = area->x + area->width;
+    int ey = area->y + area->height;
+    if (AREA_LEFT(*intersect_with) >= ex || AREA_RIGHT(*intersect_with) <= sx) return 0;
+    if (AREA_TOP(*intersect_with) >= ey || AREA_BOTTOM(*intersect_with) <= sy) return 0;
+    if (AREA_LEFT(*intersect_with) >= sx) sx = AREA_LEFT(*intersect_with);
+    if (AREA_RIGHT(*intersect_with) <= ex) ex = AREA_RIGHT(*intersect_with);
+    if (AREA_TOP(*intersect_with) >= sy) sy = AREA_TOP(*intersect_with);
+    if (AREA_BOTTOM(*intersect_with) <= ey) ey = AREA_BOTTOM(*intersect_with);
+    if (sx == ex || sy == ey) return 0;
+    area->x = sx;
+    area->y = sy;
+    area->width = ex - sx;
+    area->height = ey - sy;
+    return 1;
+}
+
 static void
 client_refresh_titlebar_partial(client_t *c, client_titlebar_t bar, int16_t x, int16_t y, uint16_t width, uint16_t height)
 {
@@ -3515,15 +3548,18 @@ client_refresh_titlebar_partial(client_t *c, client_titlebar_t bar, int16_t x, i
 
     /* Is the titlebar part of the area that should get redrawn? */
     area_t area = titlebar_get_area(c, bar);
-    if (AREA_LEFT(area) >= x + width || AREA_RIGHT(area) <= x)
-        return;
-    if (AREA_TOP(area) >= y + height || AREA_BOTTOM(area) <= y)
-        return;
-
-    /* Redraw the affected parts */
-    cairo_surface_flush(c->titlebar[bar].drawable->surface);
-    xcb_copy_area(globalconf.connection, c->titlebar[bar].drawable->pixmap, c->frame_window,
-            globalconf.gc, x - area.x, y - area.y, x, y, width, height);
+    area_t dirty_area = { .x = x, .y = y, .width = width, .height = height };
+    if (!area_intersect(&dirty_area, &area)) return;
+
+    if (c->composite_cb) {
+        xcb_clear_area(globalconf.connection, true, c->frame_window, dirty_area.x, dirty_area.y, dirty_area.width, dirty_area.height);
+    } else {
+        /* Redraw the affected parts */
+        cairo_surface_flush(c->titlebar[bar].drawable->surface);
+        xcb_copy_area(globalconf.connection, c->titlebar[bar].drawable->pixmap, c->frame_window,
+            globalconf.gc, dirty_area.x - area.x, dirty_area.y - area.y,
+            dirty_area.x, dirty_area.y, dirty_area.width, dirty_area.height);
+    }
 }
 
 #define HANDLE_TITLEBAR_REFRESH(name, index)                                                \
@@ -3538,14 +3574,89 @@ HANDLE_TITLEBAR_REFRESH(right, CLIENT_TITLEBAR_RIGHT)
 HANDLE_TITLEBAR_REFRESH(bottom, CLIENT_TITLEBAR_BOTTOM)
 HANDLE_TITLEBAR_REFRESH(left, CLIENT_TITLEBAR_LEFT)
 
+
+static void
+client_composite_titlebar_partial(client_t *c, client_titlebar_t bar, int16_t x, int16_t y, uint16_t width, uint16_t height, cairo_t *cr)
+{
+    if(c->titlebar[bar].drawable == NULL
+            || c->titlebar[bar].drawable->pixmap == XCB_NONE
+            || !c->titlebar[bar].drawable->refreshed)
+        return;
+
+    /* Is the titlebar part of the area that should get redrawn? */
+    area_t area = titlebar_get_area(c, bar);
+    area_t dirty_area = { .x = x, .y = y, .width = width, .height = height };
+    if (!area_intersect(&dirty_area, &area)) return;
+
+    cairo_save(cr);
+    cairo_rectangle(cr, dirty_area.x, dirty_area.y, dirty_area.width, dirty_area.height);
+    cairo_set_source_surface(cr, c->titlebar[bar].drawable->surface, area.x, area.y);
+    cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);
+    cairo_fill(cr);
+    cairo_restore(cr);
+}
+
+static void client_composite_partial(client_t *c, int16_t x, int16_t y, uint16_t width, uint16_t height, cairo_t *cr) {
+    int diff_left = c->titlebar[CLIENT_TITLEBAR_LEFT].size - c->titlebar[CLIENT_TITLEBAR_LEFT].overlap;
+    int diff_right = c->titlebar[CLIENT_TITLEBAR_RIGHT].size - c->titlebar[CLIENT_TITLEBAR_RIGHT].overlap;
+    int diff_top = c->titlebar[CLIENT_TITLEBAR_TOP].size - c->titlebar[CLIENT_TITLEBAR_TOP].overlap;
+    int diff_bottom = c->titlebar[CLIENT_TITLEBAR_BOTTOM].size - c->titlebar[CLIENT_TITLEBAR_BOTTOM].overlap;
+    area_t client_area = { .x = 0, .y = 0, width = c->geometry.width - diff_left - diff_right, c->geometry.height - diff_top - diff_bottom };
+    area_t dirty_area = { .x = x - diff_left, .y = y - diff_top, .width = width, .height = height };
+    if (!area_intersect(&dirty_area, &client_area)) return;
+
+    cairo_surface_t *client_surface = cairo_xcb_surface_create(
+        globalconf.connection, c->window, c->visualtype, client_area.width, client_area.height);
+    cairo_save(cr);
+    cairo_translate(cr, diff_left, diff_top);
+
+    lua_State *L = globalconf_get_lua_State();
+    luaA_object_push(L, c);
+    lua_pushlightuserdata(L, cr);
+    lua_pushlightuserdata(L, client_surface);
+    lua_pushinteger(L, dirty_area.x);
+    lua_pushinteger(L, dirty_area.y);
+    lua_pushinteger(L, dirty_area.width);
+    lua_pushinteger(L, dirty_area.height);
+    luaA_object_push(L, c->composite_cb);
+    luaA_dofunction(L, 7, 0);
+
+    cairo_surface_destroy(client_surface);
+}
+
 /**
  * Refresh all titlebars that are in the specified rectangle
  */
 void
 client_refresh_partial(client_t *c, int16_t x, int16_t y, uint16_t width, uint16_t height)
 {
-    for (client_titlebar_t bar = CLIENT_TITLEBAR_TOP; bar < CLIENT_TITLEBAR_COUNT; bar++) {
-        client_refresh_titlebar_partial(c, bar, x, y, width, height);
+    if (!c->composite_cb) {
+        for (client_titlebar_t bar = CLIENT_TITLEBAR_TOP; bar < CLIENT_TITLEBAR_COUNT; bar++) {
+            client_refresh_titlebar_partial(c, bar, x, y, width, height);
+        }
+    } else {
+        cairo_surface_t *frame_surface = cairo_xcb_surface_create(
+            globalconf.connection, c->frame_window, globalconf.visual, c->geometry.width, c->geometry.height);
+        cairo_surface_t *partial_surface =
+            cairo_surface_create_similar(frame_surface, CAIRO_CONTENT_COLOR_ALPHA, width, height);
+        cairo_t *cr;
+        cr = cairo_create(partial_surface);
+        cairo_translate(cr, -x, -y);
+        for (client_titlebar_t bar = CLIENT_TITLEBAR_TOP; bar < CLIENT_TITLEBAR_COUNT; bar++) {
+            client_composite_titlebar_partial(c, bar, x, y, width, height, cr);
+        }
+        client_composite_partial(c, x, y, width, height, cr);
+        cairo_surface_flush(partial_surface);
+        cairo_destroy(cr);
+        cr = cairo_create(frame_surface);
+        cairo_set_source_surface(cr, partial_surface, x, y);
+        cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);
+        cairo_rectangle(cr, x, y, width, height);
+        cairo_fill(cr);
+        cairo_destroy(cr);
+        cairo_surface_flush(frame_surface);
+        cairo_surface_destroy(partial_surface);
+        cairo_surface_destroy(frame_surface);
     }
 }
 
@@ -4212,6 +4323,88 @@ luaA_client_get_size_hints(lua_State *L, client_t *c)
     return 1;
 }
 
+/** Get the client's composite function.
+ * \param L The Lua VM state.
+ * \param client The client object.
+ * \return The number of elements pushed on stack.
+ */
+static int
+luaA_client_get_composite(lua_State *L, client_t *c)
+{
+    /* lua has to make sure to free the ref or we have a leak */
+    if (c->composite_cb)
+        luaA_object_push(L, c->composite_cb);
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+/** Set the client's composite function
+ * \param L The Lua VM state.
+ * \param client The client object.
+ * \return The number of elements pushed on stack.
+ */
+static int
+luaA_client_set_composite(lua_State *L, client_t *c)
+{
+    void *composite_cb = NULL;
+    if(!lua_isnil(L, -1)) {
+        luaA_checkfunction(L, -1);
+        composite_cb = luaA_object_ref(L, -1);
+    }
+
+    if (!c->composite_cb) {
+        if (composite_cb) {
+            c->damage = xcb_generate_id(globalconf.connection);
+            xcb_request_check(globalconf.connection,
+                              xcb_composite_redirect_subwindows(globalconf.connection, c->frame_window, XCB_COMPOSITE_REDIRECT_MANUAL));
+            xcb_damage_create(globalconf.connection, c->damage, c->window, XCB_DAMAGE_REPORT_LEVEL_NON_EMPTY);
+            xcb_clear_area(globalconf.connection, true, c->frame_window, 0, 0, c->geometry.width, c->geometry.height);
+        }
+    } else {
+        luaA_object_unref(L, c->composite_cb);
+        if (!composite_cb) {
+            xcb_composite_unredirect_subwindows(globalconf.connection, c->frame_window, XCB_COMPOSITE_REDIRECT_MANUAL);
+            xcb_damage_destroy(globalconf.connection, c->damage);
+            c->damage = XCB_NONE;
+        }
+    }
+    c->composite_cb = composite_cb;
+    return 0;
+}
+
+/** Invalidate an area of the client frame for redrawing.
+ *
+ * It is usually used for redrawing changes that affect the client composition, but not from the client.
+ *
+ * @tparam interger x
+ * @tparam interger y
+ * @tparam interger width
+ * @tparam interger height
+ * @method invalidate_frame
+ */
+static int
+luaA_client_invalidate_frame(lua_State *L)
+{
+    client_t *c = luaA_checkudata(L, 1, &client_class);
+    area_t client_area = {
+        .x = 0, .y = 0,
+        .width = c->geometry.width,
+        .height = c->geometry.height,
+    };
+    area_t area = {
+        .x = luaL_checkinteger(L, 2),
+        .y = luaL_checkinteger(L, 3),
+        .width = luaL_checkinteger(L, 4),
+        .height = luaL_checkinteger(L, 5),
+    };
+    if (area_intersect(&area, &client_area))
+        xcb_clear_area(globalconf.connection, true, c->frame_window,
+                       area.x, area.y, area.width, area.height);
+    return 0;
+}
+
+
 /** Get the client's child window bounding shape.
  * \param L The Lua VM state.
  * \param client The client object.
@@ -4568,6 +4761,7 @@ client_class_setup(lua_State *L)
         { "titlebar_right", luaA_client_titlebar_right },
         { "titlebar_bottom", luaA_client_titlebar_bottom },
         { "titlebar_left", luaA_client_titlebar_left },
+        { "invalidate_frame", luaA_client_invalidate_frame },
         { "get_icon", luaA_client_get_some_icon },
         { NULL, NULL }
     };
@@ -4707,6 +4901,10 @@ client_class_setup(lua_State *L)
                             (lua_class_propfunc_t) luaA_client_set_focusable,
                             (lua_class_propfunc_t) luaA_client_get_focusable,
                             (lua_class_propfunc_t) luaA_client_set_focusable);
+    luaA_class_add_property(&client_class, "composite",
+                            (lua_class_propfunc_t) luaA_client_set_composite,
+                            (lua_class_propfunc_t) luaA_client_get_composite,
+                            (lua_class_propfunc_t) luaA_client_set_composite);
     luaA_class_add_property(&client_class, "shape_bounding",
                             (lua_class_propfunc_t) luaA_client_set_shape_bounding,
                             (lua_class_propfunc_t) luaA_client_get_shape_bounding,
diff --git a/objects/client.h b/objects/client.h
index 8b517c4df0..e37d0ece9d 100644
--- a/objects/client.h
+++ b/objects/client.h
@@ -25,6 +25,8 @@
 #include "stack.h"
 #include "objects/window.h"
 
+#include <xcb/damage.h>
+
 #define CLIENT_SELECT_INPUT_EVENT_MASK (XCB_EVENT_MASK_STRUCTURE_NOTIFY \
                                         | XCB_EVENT_MASK_PROPERTY_CHANGE \
                                         | XCB_EVENT_MASK_FOCUS_CHANGE)
@@ -116,6 +118,10 @@ struct client_t
     /** Old window geometry currently configured in X11 */
     area_t x11_client_geometry;
     area_t x11_frame_geometry;
+    /** Damage handle */
+    xcb_damage_damage_t damage;
+    /** Lua composite callback */
+    void *composite_cb;
     /** Got a configure request and have to call client_send_configure() if its ignored? */
     bool got_configure_request;
     /** Startup ID */
